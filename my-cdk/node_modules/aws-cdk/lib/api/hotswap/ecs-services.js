"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = void 0;
const AWS = require("aws-sdk");
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate) {
    // the only resource change we can evaluate here is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return [];
    }
    const ret = [];
    // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
    // it contains the image and environment variables, so seems like a safe bet for now.
    // We might revisit this decision in the future though!
    const propertiesToHotswap = ['ContainerDefinitions'];
    const classifiedChanges = (0, common_1.classifyChanges)(change, propertiesToHotswap);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(r => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0) {
        // if there are no resources referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'No ECS services reference the changed task definition', false);
    }
    if (resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if something besides an ECS Service is referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        const nonEcsServiceTaskDefRefs = resourcesReferencingTaskDef.filter(r => r.Type !== 'AWS::ECS::Service');
        for (const taskRef of nonEcsServiceTaskDefRefs) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, `A resource '${taskRef.LogicalId}' with Type '${taskRef.Type}' that is not an ECS Service was found referencing the changed TaskDefinition '${logicalId}'`);
        }
    }
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        const familyName = await getFamilyName(evaluateCfnTemplate, logicalId, change);
        if (familyName === undefined) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'Failed to determine family name of the task definition', false);
            return ret;
        }
        const oldTaskDefinitionArn = await evaluateCfnTemplate.findPhysicalNameFor(logicalId);
        if (oldTaskDefinitionArn === undefined) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'Failed to determine ARN of the task definition', false);
            return ret;
        }
        const changes = await (0, common_1.evaluatableProperties)(evaluateCfnTemplate, change, propertiesToHotswap);
        if (changes.unevaluatableUpdates.length > 0) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, `Found changes that cannot be evaluated locally in the task definition - ${changes.unevaluatableUpdates.map(p => p.key.join('.')).join(', ')}`, false);
            return ret;
        }
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: namesOfHotswappableChanges,
            service: 'ecs-service',
            resourceNames: [
                `ECS Task Definition '${familyName}'`,
                ...ecsServicesReferencingTaskDef.map(ecsService => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`),
            ],
            apply: async (sdk) => {
                // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
                // we need to lowercase the evaluated TaskDef from CloudFormation,
                // as the AWS SDK uses lowercase property names for these
                // get the task definition of the family and revision corresponding to the old CFn template
                const target = await sdk
                    .ecs()
                    .describeTaskDefinition({
                    taskDefinition: oldTaskDefinitionArn,
                    include: ['TAGS'],
                })
                    .promise();
                if (target.taskDefinition === undefined) {
                    throw new Error(`Could not find a task definition: ${oldTaskDefinitionArn}. Try deploying without hotswap first.`);
                }
                // The describeTaskDefinition response contains several keys that must not exist in a registerTaskDefinition request.
                // We remove these keys here, comparing these two structs:
                // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DescribeTaskDefinition.html#API_DescribeTaskDefinition_ResponseSyntax
                [
                    'compatibilities',
                    'taskDefinitionArn',
                    'revision',
                    'status',
                    'requiresAttributes',
                    'compatibilities',
                    'registeredAt',
                    'registeredBy',
                ].forEach(key => delete target.taskDefinition[key]);
                // the tags field is in a different location in describeTaskDefinition response,
                // moving it as intended for registerTaskDefinition request.
                if (target.tags !== undefined && target.tags.length > 0) {
                    target.taskDefinition.tags = target.tags;
                    delete target.tags;
                }
                // Don't transform the properties that take arbitrary string as keys i.e. { "string" : "string" }
                // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                const excludeFromTransform = {
                    ContainerDefinitions: {
                        DockerLabels: true,
                        FirelensConfiguration: {
                            Options: true,
                        },
                        LogConfiguration: {
                            Options: true,
                        },
                    },
                    Volumes: {
                        DockerVolumeConfiguration: {
                            DriverOpts: true,
                            Labels: true,
                        },
                    },
                };
                // We first uppercase the task definition to properly merge it with the one from CloudFormation template.
                const upperCasedTaskDef = (0, common_1.transformObjectKeys)(target.taskDefinition, common_1.upperCaseFirstCharacter, excludeFromTransform);
                // merge evaluatable diff from CloudFormation template.
                const updatedTaskDef = (0, common_1.applyPropertyUpdates)(changes.updates, upperCasedTaskDef);
                // lowercase the merged task definition to use it in AWS SDK.
                const lowercasedTaskDef = (0, common_1.transformObjectKeys)(updatedTaskDef, common_1.lowerCaseFirstCharacter, excludeFromTransform);
                const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef).promise();
                const taskDefRevArn = registerTaskDefResponse.taskDefinition?.taskDefinitionArn;
                // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
                const servicePerClusterUpdates = {};
                for (const ecsService of ecsServicesReferencingTaskDef) {
                    const clusterName = ecsService.serviceArn.split('/')[1];
                    const existingClusterPromises = servicePerClusterUpdates[clusterName];
                    let clusterPromises;
                    if (existingClusterPromises) {
                        clusterPromises = existingClusterPromises;
                    }
                    else {
                        clusterPromises = [];
                        servicePerClusterUpdates[clusterName] = clusterPromises;
                    }
                    // Forcing New Deployment and setting Minimum Healthy Percent to 0.
                    // As CDK HotSwap is development only, this seems the most efficient way to ensure all tasks are replaced immediately, regardless of original amount.
                    clusterPromises.push({
                        promise: sdk.ecs().updateService({
                            service: ecsService.serviceArn,
                            taskDefinition: taskDefRevArn,
                            cluster: clusterName,
                            forceNewDeployment: true,
                            deploymentConfiguration: {
                                minimumHealthyPercent: 0,
                            },
                        }).promise(),
                        ecsService: ecsService,
                    });
                }
                await Promise.all(Object.values(servicePerClusterUpdates)
                    .map(clusterUpdates => {
                    return Promise.all(clusterUpdates.map(serviceUpdate => serviceUpdate.promise));
                }));
                // Step 3 - wait for the service deployments triggered in Step 2 to finish
                // configure a custom Waiter
                sdk.ecs().api.waiters.deploymentToFinish = {
                    name: 'DeploymentToFinish',
                    operation: 'describeServices',
                    delay: 10,
                    maxAttempts: 60,
                    acceptors: [
                        {
                            matcher: 'pathAny',
                            argument: 'failures[].reason',
                            expected: 'MISSING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'DRAINING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'INACTIVE',
                            state: 'failure',
                        },
                        {
                            matcher: 'path',
                            argument: "length(services[].deployments[? status == 'PRIMARY' && runningCount < desiredCount][]) == `0`",
                            expected: true,
                            state: 'success',
                        },
                    ],
                };
                // create a custom Waiter that uses the deploymentToFinish configuration added above
                const deploymentWaiter = new AWS.ResourceWaiter(sdk.ecs(), 'deploymentToFinish');
                // wait for all of the waiters to finish
                await Promise.all(Object.entries(servicePerClusterUpdates).map(([clusterName, serviceUpdates]) => {
                    return deploymentWaiter.wait({
                        cluster: clusterName,
                        services: serviceUpdates.map(serviceUpdate => serviceUpdate.ecsService.serviceArn),
                    }).promise();
                }));
            },
        });
    }
    return ret;
}
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
async function getFamilyName(evaluateCfnTemplate, logicalId, change) {
    const taskDefinitionResource = {
        ...change.oldValue.Properties,
        ContainerDefinitions: change.newValue.Properties?.ContainerDefinitions,
    };
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource?.Family);
    if (!familyNameOrArn) {
        // if the Family property has not been provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
        // so, take the 6th element, at index 5, and split it on '/'
        ? familyNameOrArnParts[5].split('/')[1]
        // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
        : familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    return family;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQixxQ0FBOE87QUFJdk8sS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EO0lBRTNHLHlFQUF5RTtJQUN6RSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFO1FBQ3ZELE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxNQUFNLEdBQUcsR0FBd0IsRUFBRSxDQUFDO0lBRXBDLHFGQUFxRjtJQUNyRixxRkFBcUY7SUFDckYsdURBQXVEO0lBQ3ZELE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3JELE1BQU0saUJBQWlCLEdBQUcsSUFBQSx3QkFBZSxFQUFDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3ZFLGlCQUFpQixDQUFDLG9DQUFvQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTVELHVFQUF1RTtJQUN2RSxNQUFNLDJCQUEyQixHQUFHLG1CQUFtQixDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BGLE1BQU0scUNBQXFDLEdBQUcsMkJBQTJCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3RILE1BQU0sNkJBQTZCLEdBQUcsSUFBSSxLQUFLLEVBQWMsQ0FBQztJQUM5RCxLQUFLLE1BQU0sa0JBQWtCLElBQUkscUNBQXFDLEVBQUU7UUFDdEUsTUFBTSxVQUFVLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxtQkFBbUIsQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvRixJQUFJLFVBQVUsRUFBRTtZQUNkLDZCQUE2QixDQUFDLElBQUksQ0FBQyxFQUFF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akIsTUFBbUM7SUFDbkMsTUFBTSxzQkFBc0IsR0FBNEI7UUFDdEQsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVU7UUFDN0Isb0JBQW9CLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsb0JBQW9CO0tBQ3ZFLENBQUM7SUFDQSwwQ0FBMEM7SUFDNUMsTUFBTSxlQUFlLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyw2QkFBNkIsQ0FBQyxTQUFTLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0gsSUFBSSxDQUFDLGVBQWUsRUFBRTtRQUNwQiwyRkFBMkY7UUFDM0YseUNBQXlDO1FBQ3pDLE9BQU87S0FDUjtJQUNELDhHQUE4RztJQUM5RyxzQkFBc0I7SUFDdEIsTUFBTSxvQkFBb0IsR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hELE1BQU0sTUFBTSxHQUFHLG9CQUFvQixDQUFDLE1BQU0sR0FBRyxDQUFDO1FBQzlDLDZIQUE2SDtRQUM3SCw0REFBNEQ7UUFDMUQsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsZ0dBQWdHO1FBQzlGLENBQUMsQ0FBQyxlQUFlLENBQUM7SUFDbEIsOEZBQThGO0lBRWhHLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBDaGFuZ2VIb3Rzd2FwUmVzdWx0LCBjbGFzc2lmeUNoYW5nZXMsIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIsIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZSwgdHJhbnNmb3JtT2JqZWN0S2V5cywgdXBwZXJDYXNlRmlyc3RDaGFyYWN0ZXIsIGFwcGx5UHJvcGVydHlVcGRhdGVzLCBldmFsdWF0YWJsZVByb3BlcnRpZXMgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlIH0gZnJvbSAnLi4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlKFxuICBsb2dpY2FsSWQ6IHN0cmluZywgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4ge1xuICAvLyB0aGUgb25seSByZXNvdXJjZSBjaGFuZ2Ugd2UgY2FuIGV2YWx1YXRlIGhlcmUgaXMgYW4gRUNTIFRhc2tEZWZpbml0aW9uXG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSAhPT0gJ0FXUzo6RUNTOjpUYXNrRGVmaW5pdGlvbicpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCByZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQgPSBbXTtcblxuICAvLyBXZSBvbmx5IGFsbG93IGEgY2hhbmdlIGluIHRoZSBDb250YWluZXJEZWZpbml0aW9ucyBvZiB0aGUgVGFza0RlZmluaXRpb24gZm9yIG5vdyAtXG4gIC8vIGl0IGNvbnRhaW5zIHRoZSBpbWFnZSBhbmQgZW52aXJvbm1lbnQgdmFyaWFibGVzLCBzbyBzZWVtcyBsaWtlIGEgc2FmZSBiZXQgZm9yIG5vdy5cbiAgLy8gV2UgbWlnaHQgcmV2aXNpdCB0aGlzIGRlY2lzaW9uIGluIHRoZSBmdXR1cmUgdGhvdWdoIVxuICBjb25zdCBwcm9wZXJ0aWVzVG9Ib3Rzd2FwID0gWydDb250YWluZXJEZWZpbml0aW9ucyddO1xuICBjb25zdCBjbGFzc2lmaWVkQ2hhbmdlcyA9IGNsYXNzaWZ5Q2hhbmdlcyhjaGFuZ2UsIHByb3BlcnRpZXNUb0hvdHN3YXApO1xuICBjbGFzc2lmaWVkQ2hhbmdlcy5yZXBvcnROb25Ib3Rzd2FwcGFibGVQcm9wZXJ0eUNoYW5nZXMocmV0KTtcblxuICAvLyBmaW5kIGFsbCBFQ1MgU2VydmljZXMgdGhhdCByZWZlcmVuY2UgdGhlIFRhc2tEZWZpbml0aW9uIHRoYXQgY2hhbmdlZFxuICBjb25zdCByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRSZWZlcmVuY2VzVG8obG9naWNhbElkKTtcbiAgY29uc3QgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZi5maWx0ZXIociA9PiByLlR5cGUgPT09ICdBV1M6OkVDUzo6U2VydmljZScpO1xuICBjb25zdCBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IG5ldyBBcnJheTxFY3NTZXJ2aWNlPigpO1xuICBmb3IgKGNvbnN0IGVjc1NlcnZpY2VSZXNvdXJjZSBvZiBlY3NTZXJ2aWNlUmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmKSB7XG4gICAgY29uc3Qgc2VydmljZUFybiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFBoeXNpY2FsTmFtZUZvcihlY3NTZXJ2aWNlUmVzb3VyY2UuTG9naWNhbElkKTtcbiAgICBpZiAoc2VydmljZUFybikge1xuICAgICAgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYucHVzaCh7IHNlcnZpY2VBcm4gfSk7XG4gICAgfVxuICB9XG4gIGlmIChlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5sZW5ndGggPT09IDApIHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcmVzb3VyY2VzIHJlZmVyZW5jaW5nIHRoZSBUYXNrRGVmaW5pdGlvbixcbiAgICAvLyBob3Rzd2FwIGlzIG5vdCBwb3NzaWJsZSBpbiBGQUxMX0JBQ0sgbW9kZVxuICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShyZXQsIGNoYW5nZSwgdW5kZWZpbmVkLCAnTm8gRUNTIHNlcnZpY2VzIHJlZmVyZW5jZSB0aGUgY2hhbmdlZCB0YXNrIGRlZmluaXRpb24nLCBmYWxzZSk7XG4gIH1cbiAgaWYgKHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZi5sZW5ndGggPiBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5sZW5ndGgpIHtcbiAgICAvLyBpZiBzb21ldGhpbmcgYmVzaWRlcyBhbiBFQ1MgU2VydmljZSBpcyByZWZlcmVuY2luZyB0aGUgVGFza0RlZmluaXRpb24sXG4gICAgLy8gaG90c3dhcCBpcyBub3QgcG9zc2libGUgaW4gRkFMTF9CQUNLIG1vZGVcbiAgICBjb25zdCBub25FY3NTZXJ2aWNlVGFza0RlZlJlZnMgPSByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYuZmlsdGVyKHIgPT4gci5UeXBlICE9PSAnQVdTOjpFQ1M6OlNlcnZpY2UnKTtcbiAgICBmb3IgKGNvbnN0IHRhc2tSZWYgb2Ygbm9uRWNzU2VydmljZVRhc2tEZWZSZWZzKSB7XG4gICAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UocmV0LCBjaGFuZ2UsIHVuZGVmaW5lZCwgYEEgcmVzb3VyY2UgJyR7dGFza1JlZi5Mb2dpY2FsSWR9JyB3aXRoIFR5cGUgJyR7dGFza1JlZi5UeXBlfScgdGhhdCBpcyBub3QgYW4gRUNTIFNlcnZpY2Ugd2FzIGZvdW5kIHJlZmVyZW5jaW5nIHRoZSBjaGFuZ2VkIFRhc2tEZWZpbml0aW9uICcke2xvZ2ljYWxJZH0nYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMgPSBPYmplY3Qua2V5cyhjbGFzc2lmaWVkQ2hhbmdlcy5ob3Rzd2FwcGFibGVQcm9wcyk7XG4gIGlmIChuYW1lc09mSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmFtaWx5TmFtZSA9IGF3YWl0IGdldEZhbWlseU5hbWUoZXZhbHVhdGVDZm5UZW1wbGF0ZSwgbG9naWNhbElkLCBjaGFuZ2UpO1xuICAgIGlmIChmYW1pbHlOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShyZXQsIGNoYW5nZSwgdW5kZWZpbmVkLCAnRmFpbGVkIHRvIGRldGVybWluZSBmYW1pbHkgbmFtZSBvZiB0aGUgdGFzayBkZWZpbml0aW9uJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgY29uc3Qgb2xkVGFza0RlZmluaXRpb25Bcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRQaHlzaWNhbE5hbWVGb3IobG9naWNhbElkKTtcbiAgICBpZiAob2xkVGFza0RlZmluaXRpb25Bcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlKHJldCwgY2hhbmdlLCB1bmRlZmluZWQsICdGYWlsZWQgdG8gZGV0ZXJtaW5lIEFSTiBvZiB0aGUgdGFzayBkZWZpbml0aW9uJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgZXZhbHVhdGFibGVQcm9wZXJ0aWVzKGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIGNoYW5nZSwgcHJvcGVydGllc1RvSG90c3dhcCk7XG4gICAgaWYgKGNoYW5nZXMudW5ldmFsdWF0YWJsZVVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlKHJldCwgY2hhbmdlLCB1bmRlZmluZWQsIGBGb3VuZCBjaGFuZ2VzIHRoYXQgY2Fubm90IGJlIGV2YWx1YXRlZCBsb2NhbGx5IGluIHRoZSB0YXNrIGRlZmluaXRpb24gLSAke1xuICAgICAgICBjaGFuZ2VzLnVuZXZhbHVhdGFibGVVcGRhdGVzLm1hcChwID0+IHAua2V5LmpvaW4oJy4nKSkuam9pbignLCAnKVxuICAgICAgfWAsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0LnB1c2goe1xuICAgICAgaG90c3dhcHBhYmxlOiB0cnVlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICAgIHByb3BzQ2hhbmdlZDogbmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMsXG4gICAgICBzZXJ2aWNlOiAnZWNzLXNlcnZpY2UnLFxuICAgICAgcmVzb3VyY2VOYW1lczogW1xuICAgICAgICBgRUNTIFRhc2sgRGVmaW5pdGlvbiAnJHtmYW1pbHlOYW1lfSdgLFxuICAgICAgICAuLi5lY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5tYXAoZWNzU2VydmljZSA9PiBgRUNTIFNlcnZpY2UgJyR7ZWNzU2VydmljZS5zZXJ2aWNlQXJuLnNwbGl0KCcvJylbMl19J2ApLFxuICAgICAgXSxcbiAgICAgIGFwcGx5OiBhc3luYyAoc2RrOiBJU0RLKSA9PiB7XG4gICAgICAgIC8vIFN0ZXAgMSAtIHVwZGF0ZSB0aGUgY2hhbmdlZCBUYXNrRGVmaW5pdGlvbiwgY3JlYXRpbmcgYSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICAgICAgLy8gd2UgbmVlZCB0byBsb3dlcmNhc2UgdGhlIGV2YWx1YXRlZCBUYXNrRGVmIGZyb20gQ2xvdWRGb3JtYXRpb24sXG4gICAgICAgIC8vIGFzIHRoZSBBV1MgU0RLIHVzZXMgbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIGZvciB0aGVzZVxuXG4gICAgICAgIC8vIGdldCB0aGUgdGFzayBkZWZpbml0aW9uIG9mIHRoZSBmYW1pbHkgYW5kIHJldmlzaW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9sZCBDRm4gdGVtcGxhdGVcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXdhaXQgc2RrXG4gICAgICAgICAgLmVjcygpXG4gICAgICAgICAgLmRlc2NyaWJlVGFza0RlZmluaXRpb24oe1xuICAgICAgICAgICAgdGFza0RlZmluaXRpb246IG9sZFRhc2tEZWZpbml0aW9uQXJuLFxuICAgICAgICAgICAgaW5jbHVkZTogWydUQUdTJ10sXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucHJvbWlzZSgpO1xuICAgICAgICBpZiAodGFyZ2V0LnRhc2tEZWZpbml0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgdGFzayBkZWZpbml0aW9uOiAke29sZFRhc2tEZWZpbml0aW9uQXJufS4gVHJ5IGRlcGxveWluZyB3aXRob3V0IGhvdHN3YXAgZmlyc3QuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZGVzY3JpYmVUYXNrRGVmaW5pdGlvbiByZXNwb25zZSBjb250YWlucyBzZXZlcmFsIGtleXMgdGhhdCBtdXN0IG5vdCBleGlzdCBpbiBhIHJlZ2lzdGVyVGFza0RlZmluaXRpb24gcmVxdWVzdC5cbiAgICAgICAgLy8gV2UgcmVtb3ZlIHRoZXNlIGtleXMgaGVyZSwgY29tcGFyaW5nIHRoZXNlIHR3byBzdHJ1Y3RzOlxuICAgICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uRUNTL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX1JlZ2lzdGVyVGFza0RlZmluaXRpb24uaHRtbCNBUElfUmVnaXN0ZXJUYXNrRGVmaW5pdGlvbl9SZXF1ZXN0U3ludGF4XG4gICAgICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25FQ1MvbGF0ZXN0L0FQSVJlZmVyZW5jZS9BUElfRGVzY3JpYmVUYXNrRGVmaW5pdGlvbi5odG1sI0FQSV9EZXNjcmliZVRhc2tEZWZpbml0aW9uX1Jlc3BvbnNlU3ludGF4XG4gICAgICAgIFtcbiAgICAgICAgICAnY29tcGF0aWJpbGl0aWVzJyxcbiAgICAgICAgICAndGFza0RlZmluaXRpb25Bcm4nLFxuICAgICAgICAgICdyZXZpc2lvbicsXG4gICAgICAgICAgJ3N0YXR1cycsXG4gICAgICAgICAgJ3JlcXVpcmVzQXR0cmlidXRlcycsXG4gICAgICAgICAgJ2NvbXBhdGliaWxpdGllcycsXG4gICAgICAgICAgJ3JlZ2lzdGVyZWRBdCcsXG4gICAgICAgICAgJ3JlZ2lzdGVyZWRCeScsXG4gICAgICAgIF0uZm9yRWFjaChrZXk9PiBkZWxldGUgKHRhcmdldC50YXNrRGVmaW5pdGlvbiBhcyBhbnkpW2tleV0pO1xuXG4gICAgICAgIC8vIHRoZSB0YWdzIGZpZWxkIGlzIGluIGEgZGlmZmVyZW50IGxvY2F0aW9uIGluIGRlc2NyaWJlVGFza0RlZmluaXRpb24gcmVzcG9uc2UsXG4gICAgICAgIC8vIG1vdmluZyBpdCBhcyBpbnRlbmRlZCBmb3IgcmVnaXN0ZXJUYXNrRGVmaW5pdGlvbiByZXF1ZXN0LlxuICAgICAgICBpZiAodGFyZ2V0LnRhZ3MgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQudGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgKHRhcmdldC50YXNrRGVmaW5pdGlvbiBhcyBhbnkpLnRhZ3MgPSB0YXJnZXQudGFncztcbiAgICAgICAgICBkZWxldGUgdGFyZ2V0LnRhZ3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCB0cmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgdGhhdCB0YWtlIGFyYml0cmFyeSBzdHJpbmcgYXMga2V5cyBpLmUuIHsgXCJzdHJpbmdcIiA6IFwic3RyaW5nXCIgfVxuICAgICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uRUNTL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX1JlZ2lzdGVyVGFza0RlZmluaXRpb24uaHRtbCNBUElfUmVnaXN0ZXJUYXNrRGVmaW5pdGlvbl9SZXF1ZXN0U3ludGF4XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVGcm9tVHJhbnNmb3JtID0ge1xuICAgICAgICAgIENvbnRhaW5lckRlZmluaXRpb25zOiB7XG4gICAgICAgICAgICBEb2NrZXJMYWJlbHM6IHRydWUsXG4gICAgICAgICAgICBGaXJlbGVuc0NvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgT3B0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBMb2dDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgIE9wdGlvbnM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgVm9sdW1lczoge1xuICAgICAgICAgICAgRG9ja2VyVm9sdW1lQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICBEcml2ZXJPcHRzOiB0cnVlLFxuICAgICAgICAgICAgICBMYWJlbHM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0gYXMgY29uc3Q7XG4gICAgICAgIC8vIFdlIGZpcnN0IHVwcGVyY2FzZSB0aGUgdGFzayBkZWZpbml0aW9uIHRvIHByb3Blcmx5IG1lcmdlIGl0IHdpdGggdGhlIG9uZSBmcm9tIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlLlxuICAgICAgICBjb25zdCB1cHBlckNhc2VkVGFza0RlZiA9IHRyYW5zZm9ybU9iamVjdEtleXModGFyZ2V0LnRhc2tEZWZpbml0aW9uLCB1cHBlckNhc2VGaXJzdENoYXJhY3RlciwgZXhjbHVkZUZyb21UcmFuc2Zvcm0pO1xuICAgICAgICAvLyBtZXJnZSBldmFsdWF0YWJsZSBkaWZmIGZyb20gQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGUuXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRUYXNrRGVmID0gYXBwbHlQcm9wZXJ0eVVwZGF0ZXMoY2hhbmdlcy51cGRhdGVzLCB1cHBlckNhc2VkVGFza0RlZik7XG4gICAgICAgIC8vIGxvd2VyY2FzZSB0aGUgbWVyZ2VkIHRhc2sgZGVmaW5pdGlvbiB0byB1c2UgaXQgaW4gQVdTIFNESy5cbiAgICAgICAgY29uc3QgbG93ZXJjYXNlZFRhc2tEZWYgPSB0cmFuc2Zvcm1PYmplY3RLZXlzKHVwZGF0ZWRUYXNrRGVmLCBsb3dlckNhc2VGaXJzdENoYXJhY3RlciwgZXhjbHVkZUZyb21UcmFuc2Zvcm0pO1xuXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlID0gYXdhaXQgc2RrLmVjcygpLnJlZ2lzdGVyVGFza0RlZmluaXRpb24obG93ZXJjYXNlZFRhc2tEZWYpLnByb21pc2UoKTtcbiAgICAgICAgY29uc3QgdGFza0RlZlJldkFybiA9IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlLnRhc2tEZWZpbml0aW9uPy50YXNrRGVmaW5pdGlvbkFybjtcblxuICAgICAgICAvLyBTdGVwIDIgLSB1cGRhdGUgdGhlIHNlcnZpY2VzIHVzaW5nIHRoYXQgVGFza0RlZmluaXRpb24gdG8gcG9pbnQgdG8gdGhlIG5ldyBUYXNrRGVmaW5pdGlvbiBSZXZpc2lvblxuICAgICAgICBjb25zdCBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXM6IHsgW2NsdXN0ZXI6IHN0cmluZ106IEFycmF5PHsgcHJvbWlzZTogUHJvbWlzZTxhbnk+LCBlY3NTZXJ2aWNlOiBFY3NTZXJ2aWNlIH0+IH0gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBlY3NTZXJ2aWNlIG9mIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmKSB7XG4gICAgICAgICAgY29uc3QgY2x1c3Rlck5hbWUgPSBlY3NTZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsxXTtcblxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2x1c3RlclByb21pc2VzID0gc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzW2NsdXN0ZXJOYW1lXTtcbiAgICAgICAgICBsZXQgY2x1c3RlclByb21pc2VzOiBBcnJheTx7IHByb21pc2U6IFByb21pc2U8YW55PiwgZWNzU2VydmljZTogRWNzU2VydmljZSB9PjtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXMpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJQcm9taXNlcyA9IGV4aXN0aW5nQ2x1c3RlclByb21pc2VzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHVzdGVyUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlc1tjbHVzdGVyTmFtZV0gPSBjbHVzdGVyUHJvbWlzZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEZvcmNpbmcgTmV3IERlcGxveW1lbnQgYW5kIHNldHRpbmcgTWluaW11bSBIZWFsdGh5IFBlcmNlbnQgdG8gMC5cbiAgICAgICAgICAvLyBBcyBDREsgSG90U3dhcCBpcyBkZXZlbG9wbWVudCBvbmx5LCB0aGlzIHNlZW1zIHRoZSBtb3N0IGVmZmljaWVudCB3YXkgdG8gZW5zdXJlIGFsbCB0YXNrcyBhcmUgcmVwbGFjZWQgaW1tZWRpYXRlbHksIHJlZ2FyZGxlc3Mgb2Ygb3JpZ2luYWwgYW1vdW50LlxuICAgICAgICAgIGNsdXN0ZXJQcm9taXNlcy5wdXNoKHtcbiAgICAgICAgICAgIHByb21pc2U6IHNkay5lY3MoKS51cGRhdGVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgc2VydmljZTogZWNzU2VydmljZS5zZXJ2aWNlQXJuLFxuICAgICAgICAgICAgICB0YXNrRGVmaW5pdGlvbjogdGFza0RlZlJldkFybixcbiAgICAgICAgICAgICAgY2x1c3RlcjogY2x1c3Rlck5hbWUsXG4gICAgICAgICAgICAgIGZvcmNlTmV3RGVwbG95bWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGVwbG95bWVudENvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtSGVhbHRoeVBlcmNlbnQ6IDAsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KS5wcm9taXNlKCksXG4gICAgICAgICAgICBlY3NTZXJ2aWNlOiBlY3NTZXJ2aWNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzKVxuICAgICAgICAgIC5tYXAoY2x1c3RlclVwZGF0ZXMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNsdXN0ZXJVcGRhdGVzLm1hcChzZXJ2aWNlVXBkYXRlID0+IHNlcnZpY2VVcGRhdGUucHJvbWlzZSkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFN0ZXAgMyAtIHdhaXQgZm9yIHRoZSBzZXJ2aWNlIGRlcGxveW1lbnRzIHRyaWdnZXJlZCBpbiBTdGVwIDIgdG8gZmluaXNoXG4gICAgICAgIC8vIGNvbmZpZ3VyZSBhIGN1c3RvbSBXYWl0ZXJcbiAgICAgICAgKHNkay5lY3MoKSBhcyBhbnkpLmFwaS53YWl0ZXJzLmRlcGxveW1lbnRUb0ZpbmlzaCA9IHtcbiAgICAgICAgICBuYW1lOiAnRGVwbG95bWVudFRvRmluaXNoJyxcbiAgICAgICAgICBvcGVyYXRpb246ICdkZXNjcmliZVNlcnZpY2VzJyxcbiAgICAgICAgICBkZWxheTogMTAsXG4gICAgICAgICAgbWF4QXR0ZW1wdHM6IDYwLFxuICAgICAgICAgIGFjY2VwdG9yczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgICAgIGFyZ3VtZW50OiAnZmFpbHVyZXNbXS5yZWFzb24nLFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ01JU1NJTkcnLFxuICAgICAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcjogJ3BhdGhBbnknLFxuICAgICAgICAgICAgICBhcmd1bWVudDogJ3NlcnZpY2VzW10uc3RhdHVzJyxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdEUkFJTklORycsXG4gICAgICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgICAgIGFyZ3VtZW50OiAnc2VydmljZXNbXS5zdGF0dXMnLFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ0lOQUNUSVZFJyxcbiAgICAgICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1hdGNoZXI6ICdwYXRoJyxcbiAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibGVuZ3RoKHNlcnZpY2VzW10uZGVwbG95bWVudHNbPyBzdGF0dXMgPT0gJ1BSSU1BUlknICYmIHJ1bm5pbmdDb3VudCA8IGRlc2lyZWRDb3VudF1bXSkgPT0gYDBgXCIsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICBzdGF0ZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgICAvLyBjcmVhdGUgYSBjdXN0b20gV2FpdGVyIHRoYXQgdXNlcyB0aGUgZGVwbG95bWVudFRvRmluaXNoIGNvbmZpZ3VyYXRpb24gYWRkZWQgYWJvdmVcbiAgICAgICAgY29uc3QgZGVwbG95bWVudFdhaXRlciA9IG5ldyAoQVdTIGFzIGFueSkuUmVzb3VyY2VXYWl0ZXIoc2RrLmVjcygpLCAnZGVwbG95bWVudFRvRmluaXNoJyk7XG4gICAgICAgIC8vIHdhaXQgZm9yIGFsbCBvZiB0aGUgd2FpdGVycyB0byBmaW5pc2hcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMoc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzKS5tYXAoKFtjbHVzdGVyTmFtZSwgc2VydmljZVVwZGF0ZXNdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGRlcGxveW1lbnRXYWl0ZXIud2FpdCh7XG4gICAgICAgICAgICBjbHVzdGVyOiBjbHVzdGVyTmFtZSxcbiAgICAgICAgICAgIHNlcnZpY2VzOiBzZXJ2aWNlVXBkYXRlcy5tYXAoc2VydmljZVVwZGF0ZSA9PiBzZXJ2aWNlVXBkYXRlLmVjc1NlcnZpY2Uuc2VydmljZUFybiksXG4gICAgICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuaW50ZXJmYWNlIEVjc1NlcnZpY2Uge1xuICByZWFkb25seSBzZXJ2aWNlQXJuOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEZhbWlseU5hbWUoXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgbG9naWNhbElkOiBzdHJpbmcsXG4gIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlKSB7XG4gIGNvbnN0IHRhc2tEZWZpbml0aW9uUmVzb3VyY2U6IHsgW25hbWU6IHN0cmluZ106IGFueSB9ID0ge1xuICAgIC4uLmNoYW5nZS5vbGRWYWx1ZS5Qcm9wZXJ0aWVzLFxuICAgIENvbnRhaW5lckRlZmluaXRpb25zOiBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcz8uQ29udGFpbmVyRGVmaW5pdGlvbnMsXG4gIH07XG4gICAgLy8gZmlyc3QsIGxldCdzIGdldCB0aGUgbmFtZSBvZiB0aGUgZmFtaWx5XG4gIGNvbnN0IGZhbWlseU5hbWVPckFybiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUobG9naWNhbElkLCB0YXNrRGVmaW5pdGlvblJlc291cmNlPy5GYW1pbHkpO1xuICBpZiAoIWZhbWlseU5hbWVPckFybikge1xuICAgIC8vIGlmIHRoZSBGYW1pbHkgcHJvcGVydHkgaGFzIG5vdCBiZWVuIHByb3ZpZGVkLCBhbmQgd2UgY2FuJ3QgZmluZCBpdCBpbiB0aGUgY3VycmVudCBTdGFjayxcbiAgICAvLyB0aGlzIG1lYW5zIGhvdHN3YXBwaW5nIGlzIG5vdCBwb3NzaWJsZVxuICAgIHJldHVybjtcbiAgfVxuICAvLyB0aGUgcGh5c2ljYWwgbmFtZSBvZiB0aGUgVGFzayBEZWZpbml0aW9uIGluIENsb3VkRm9ybWF0aW9uIGluY2x1ZGVzIGl0cyBjdXJyZW50IHJldmlzaW9uIG51bWJlciBhdCB0aGUgZW5kLFxuICAvLyByZW1vdmUgaXQgaWYgbmVlZGVkXG4gIGNvbnN0IGZhbWlseU5hbWVPckFyblBhcnRzID0gZmFtaWx5TmFtZU9yQXJuLnNwbGl0KCc6Jyk7XG4gIGNvbnN0IGZhbWlseSA9IGZhbWlseU5hbWVPckFyblBhcnRzLmxlbmd0aCA+IDFcbiAgLy8gZmFtaWx5TmFtZU9yQXJuIGlzIGFjdHVhbGx5IGFuIEFSTiwgb2YgdGhlIGZvcm1hdCAnYXJuOmF3czplY3M6cmVnaW9uOmFjY291bnQ6dGFzay1kZWZpbml0aW9uLzxmYW1pbHktbmFtZT46PHJldmlzaW9uLW5yPidcbiAgLy8gc28sIHRha2UgdGhlIDZ0aCBlbGVtZW50LCBhdCBpbmRleCA1LCBhbmQgc3BsaXQgaXQgb24gJy8nXG4gICAgPyBmYW1pbHlOYW1lT3JBcm5QYXJ0c1s1XS5zcGxpdCgnLycpWzFdXG4gIC8vIG90aGVyd2lzZSwgZmFtaWx5TmFtZU9yQXJuIGlzIGp1c3QgdGhlIHNpbXBsZSBuYW1lIGV2YWx1YXRlZCBmcm9tIHRoZSBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZVxuICAgIDogZmFtaWx5TmFtZU9yQXJuO1xuICAgIC8vIHRoZW4sIGxldCdzIGV2YWx1YXRlIHRoZSBib2R5IG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIFRhc2tEZWYgKHdpdGhvdXQgdGhlIEZhbWlseSBwcm9wZXJ0eSlcblxuICByZXR1cm4gZmFtaWx5O1xufVxuIl19